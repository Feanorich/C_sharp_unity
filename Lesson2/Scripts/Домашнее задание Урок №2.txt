    1. Расписать в текстовом документе зачем нужны интерфейсы и их отличие от классов

Интерфейс схож с абстрактным классом - нельзя создать экземпляр, и нужен, чтобы обязать программиста
реализовать определенные методы в производных классах.

Но, в отличии от абстрактного класса, поддерживает множественное наследование. 
Что удобно при использовании полиморфизма.

    2. Расписать в текстовом документе зачем нужны обобщения

Обобщения применяются, когда нужно реализовать метод с определенной логикой, 
но когда входящие переменные могут быть разных типов. Обобщения позволяют не плодить 
перегрузки с одним и тем же количеством параметров и одинаковой логикой.

    3. Добавить в игру положительные бонусы, которые необходимо обязательно собрать для победы

- пока нет. В принципе это прописано в методичке (и работы от меня не требуется), 
но я пока не прикрутил интерфейс, куда это все выводить.

    4. Добавить в игру положительные бонусы, 
    5. Добавить в игру различные ловушки 

Пока только положительное ускорение - отрицательное замедление. У класса Player реализован список 
висящих на нем бонусов (производных от класса Bonus). Благодаря этому эффепкты бонусов суммируются, 
а так же у каждого бонуса свое время действия. Благодаря этому, наклепать разных бонусов не сложно, 
но я хочу освоить Scriptable object, как вы советовали на вебинаре

    6. Реализовать статический импорт класса Debug, где это необходимо

Не понял где это может быть необходимо. Как по мне - это только путает, ибо не понимаешь твой это метод, 
или из подключенного пространства. Но реализовал в классе Player (чтобы показать, что понимаю как это).

    7. * Реализовать интерфейс ICloneable для клонирование game object

не много не понял, как это для game object? Это ведь не partial класс, и мы не можем добавлять в него методы.

    8. * Реализовать интерфейс IDisposable для игрока, ловушек и бонусов

Вроде реализовал, насколько я это вообще понял.

    9. Еще вы просили написать, что значит быть хорошим программистом.

Думаю, что для программиста важно уметь понимать (представлять?) алгоритм, который он хочет реализовать 
(понимать в отрыве от языка программирования - чисто на уровне причинно-следственных связей) 


